{"version":3,"sources":["../../app-es6/services/ConnectionFactory.js"],"names":["stores","version","dbName","connection","close","ConnectionFactory","Error","Promise","resolve","reject","openRequest","window","indexedDB","open","onupgradeneeded","_createStores","e","target","result","onsuccess","bind","onerror","console","log","error","name","forEach","objectStoreNames","contains","store","deleteObjectStore","createObjectStore","autoIncrement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAMA,kB,GAAS,CAAC,aAAD,C;AACTC,mB,GAAU,C;AACVC,kB,GAAS,Y;AAEXC,sB,GAAa,I;AAEbC,iB,GAAQ,I;;yCAECC,iB;AACT,6CAAc;AAAA;;AACV;AACA,0BAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACH;;;;oDAEsB;AAAE;AACrB,+BAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAAE;AACtC;AACA,gCAAIC,cAAcC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBX,MAAtB,EAA8BD,OAA9B,CAAlB,CAFoC,CAEqB;;AAEzD;;AAEA;AACAS,wCAAYI,eAAZ,GAA8B,aAAK;AAAE;AACjCT,kDAAkBU,aAAlB,CAAgCC,EAAEC,MAAF,CAASC,MAAzC,EAD+B,CACkB;AACpD,6BAFD;;AAIA;AACAR,wCAAYS,SAAZ,GAAwB,aAAK;AACzB,oCAAI,CAAChB,UAAL,EAAiB;AAAE;AACfA,iDAAaa,EAAEC,MAAF,CAASC,MAAtB,CADa,CACgB;AAC7Bd,4CAAQD,WAAWC,KAAX,CAAiBgB,IAAjB,CAAsBjB,UAAtB,CAAR,CAFa,CAE6B;AAC1CA,+CAAWC,KAAX,GAAmB,YAAY;AAAE;AAC7B,8CAAM,IAAIE,KAAJ,CAAU,4CAAV,CAAN;AACH,qCAFD;AAGH;;AAEDE,wCAAQL,UAAR,EATyB,CASL;AACvB,6BAVD;;AAYA;AACAO,wCAAYW,OAAZ,GAAsB,aAAK;AACvBC,wCAAQC,GAAR,CAAYP,EAAEC,MAAF,CAASO,KAArB,EADuB,CACK;AAC5Bf,uCAAOO,EAAEC,MAAF,CAASO,KAAT,CAAeC,IAAtB,EAFuB,CAEK;AAC/B,6BAHD;AAKH,yBA9BM,CAAP;AA+BH;;;kDAEoBtB,U,EAAY;AAAE;AAC/BH,+BAAO0B,OAAP,CAAe,iBAAS;AAAE;AACtB,gCAAIvB,WAAWwB,gBAAX,CAA4BC,QAA5B,CAAqCC,KAArC,CAAJ,EAAiD;AAC7C1B,2CAAW2B,iBAAX,CAA6BD,KAA7B,EAFgB,CAEoB;;AAExC;AACA1B,uCAAW4B,iBAAX,CAA6BF,KAA7B,EAAoC,EAAEG,eAAe,IAAjB,EAApC;AACH,yBAND;AAOH;;;sDAEwB;AAAE;AACvB,4BAAI7B,UAAJ,EAAgB;AAAE;AACdC,oCADY,CACJ;AACRD,yCAAa,IAAb,CAFY,CAEM;AACrB;AACJ","file":"ConnectionFactory.js","sourcesContent":["const stores = ['negociacoes']\nconst version = 4\nconst dbName = 'aluraframe'\n\nlet connection = null\n\nlet close = null\n\nexport class ConnectionFactory {\n    constructor() {\n        //Exibindo uma mensagem de erro, caso tentem instanciar a class ConnectionFactory\n        throw new Error(\"Não é possível criar instâncias de ConnectionFactory\")\n    }\n\n    static getConnection() { //Criando o método estatico getConnection, para retornar os dados da conexão\n        return new Promise((resolve, reject) => { //Retornando para o metodo uma promesa\n            //Fazendo uma requisição de abertura para o banco de dados indexedDB\n            let openRequest = window.indexedDB.open(dbName, version) //Criando o banco aluraframe, (nome do banco, versão do banco)\n\n            //TRIADE DE EVENTOS DA CONEXÃO\n\n            //Este evento cria ou altera um banco já eistente\n            openRequest.onupgradeneeded = e => { //Quando este evento for disparada a função recebe os dados do evento como prametro\n                ConnectionFactory._createStores(e.target.result) //Chamando ao metodo estatico passando os dados da conexão como parametro\n            }\n\n            //Este evento é executado quando conseguir estabelecer uma conexão\n            openRequest.onsuccess = e => {\n                if (!connection) { //Se connection for nula, faça\n                    connection = e.target.result //connection receber os dados da conexão\n                    close = connection.close.bind(connection) //Fazendo um backup da função de fechar a conexão, para a variavel close, tendo a variavel connection como referencia para o this\n                    connection.close = function () { //Alterando a função do metodo close, para que não possa ser fechado diretamente por qualquer um\n                        throw new Error(\"Você não pode fechar diretamente a conexão\")\n                    }\n                }\n\n                resolve(connection) //Passando para o resolve da promise, como resultado de sucesso, a connection\n            }\n\n            //Este evento é executado se houver algum erro na conexão\n            openRequest.onerror = e => {\n                console.log(e.target.error) //Se a conexão não tiver sido bem estabelecidade, imprima no console o erro\n                reject(e.target.error.name) //Retornando para o reject da promise, como resultado de erro, uma mensagem de erro\n            }\n\n        })\n    }\n\n    static _createStores(connection) { //Criando um método estatico para evitar repetição de código\n        stores.forEach(store => { //Percorrendo o array stores para criar ObjectStores com os nomes dentro do array\n            if (connection.objectStoreNames.contains(store)) //Conferindo se já existe algum ObjectStore já criado com o nome da posição do array, se sim, faça\n                connection.deleteObjectStore(store) //Se já existir apague ela\n\n            //Após apagar a ObjectStore acima, crie novamente, com o mesmo nome, e tendo sua chave como auto Incremento\n            connection.createObjectStore(store, { autoIncrement: true })\n        })\n    }\n\n    static closeConnection() { //Método estatico para fechar a conexão\n        if (connection) { //Se existir a conexão, faça\n            close() //Fechando a conexão\n            connection = null //E definir a variavel connection como null\n        }\n    }\n}"]}