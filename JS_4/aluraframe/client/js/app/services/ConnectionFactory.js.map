{"version":3,"sources":["../../app-es6/services/ConnectionFactory.js"],"names":["ConnectionFactory","stores","version","dbName","connection","close","Error","Promise","resolve","reject","openRequest","window","indexedDB","open","onupgradeneeded","_createStores","e","target","result","onsuccess","bind","onerror","console","log","error","name","forEach","objectStoreNames","contains","store","deleteObjectStore","createObjectStore","autoIncrement"],"mappings":";;;;;;AAAA;AACA,IAAIA,oBAAqB,YAAU;AAC/B,QAAMC,SAAS,CAAC,aAAD,CAAf;AACA,QAAMC,UAAU,CAAhB;AACA,QAAMC,SAAS,YAAf;;AAEA,QAAIC,aAAa,IAAjB;;AAEA,QAAIC,QAAQ,IAAZ;;AAEA;AACI,qCAAa;AAAA;;AACT;AACA,kBAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACH;;AAJL;AAAA;AAAA,4CAM0B;AAAE;AACpB,uBAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAAE;AACtC;AACA,wBAAIC,cAAcC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBV,MAAtB,EAA8BD,OAA9B,CAAlB,CAFoC,CAEqB;;AAEzD;;AAEA;AACAQ,gCAAYI,eAAZ,GAA8B,aAAK;AAAE;AACjCd,0CAAkBe,aAAlB,CAAgCC,EAAEC,MAAF,CAASC,MAAzC,EAD+B,CACkB;AACpD,qBAFD;;AAIA;AACAR,gCAAYS,SAAZ,GAAwB,aAAK;AACzB,4BAAG,CAACf,UAAJ,EAAe;AAAE;AACbA,yCAAaY,EAAEC,MAAF,CAASC,MAAtB,CADW,CACkB;AAC7Bb,oCAAQD,WAAWC,KAAX,CAAiBe,IAAjB,CAAsBhB,UAAtB,CAAR,CAFW,CAE+B;AAC1CA,uCAAWC,KAAX,GAAmB,YAAW;AAAE;AAC5B,sCAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AACH,6BAFD;AAGH;;AAEDE,gCAAQJ,UAAR,EATyB,CASL;AACvB,qBAVD;;AAYA;AACAM,gCAAYW,OAAZ,GAAsB,aAAK;AACvBC,gCAAQC,GAAR,CAAYP,EAAEC,MAAF,CAASO,KAArB,EADuB,CACK;AAC5Bf,+BAAOO,EAAEC,MAAF,CAASO,KAAT,CAAeC,IAAtB,EAFuB,CAEK;AAC/B,qBAHD;AAKH,iBA9BM,CAAP;AA+BH;AAtCL;AAAA;AAAA,0CAwCyBrB,UAxCzB,EAwCoC;AAAE;AAC9BH,uBAAOyB,OAAP,CAAe,iBAAS;AAAE;AACtB,wBAAGtB,WAAWuB,gBAAX,CAA4BC,QAA5B,CAAqCC,KAArC,CAAH,EAAgD;AAC5CzB,mCAAW0B,iBAAX,CAA6BD,KAA7B,EAFgB,CAEoB;;AAExC;AACAzB,+BAAW2B,iBAAX,CAA6BF,KAA7B,EAAoC,EAACG,eAAe,IAAhB,EAApC;AACH,iBAND;AAOH;AAhDL;AAAA;AAAA,8CAkD4B;AAAE;AACtB,oBAAG5B,UAAH,EAAe;AAAE;AACbC,4BADW,CACH;AACRD,iCAAa,IAAb,CAFW,CAEO;AACrB;AACJ;AAvDL;;AAAA;AAAA;AAyDH,CAlEuB,EAAxB","file":"ConnectionFactory.js","sourcesContent":["//Colocando tudo dentro de uma função auto invocavel para os dados sairem de um escopo global, onde todos poderiam ter acesso e colocando em um escopo fechado de uma função, retornando a class ConnectionFactory e passando a mesma para a variavel ConnectionFactory\nvar ConnectionFactory = (function(){\n    const stores = ['negociacoes']\n    const version = 4\n    const dbName = 'aluraframe'\n\n    var connection = null\n\n    var close = null\n\n    return  class ConnectionFactory{\n        constructor(){\n            //Exibindo uma mensagem de erro, caso tentem instanciar a class ConnectionFactory\n            throw new Error(\"Não é possível criar instâncias de ConnectionFactory\")\n        }\n\n        static getConnection(){ //Criando o método estatico getConnection, para retornar os dados da conexão\n            return new Promise((resolve, reject) => { //Retornando para o metodo uma promesa\n                //Fazendo uma requisição de abertura para o banco de dados indexedDB\n                let openRequest = window.indexedDB.open(dbName, version) //Criando o banco aluraframe, (nome do banco, versão do banco)\n\n                //TRIADE DE EVENTOS DA CONEXÃO\n\n                //Este evento cria ou altera um banco já eistente\n                openRequest.onupgradeneeded = e => { //Quando este evento for disparada a função recebe os dados do evento como prametro\n                    ConnectionFactory._createStores(e.target.result) //Chamando ao metodo estatico passando os dados da conexão como parametro\n                }\n\n                //Este evento é executado quando conseguir estabelecer uma conexão\n                openRequest.onsuccess = e => {\n                    if(!connection){ //Se connection for nula, faça\n                        connection = e.target.result //connection receber os dados da conexão\n                        close = connection.close.bind(connection) //Fazendo um backup da função de fechar a conexão, para a variavel close, tendo a variavel connection como referencia para o this\n                        connection.close = function() { //Alterando a função do metodo close, para que não possa ser fechado diretamente por qualquer um\n                            throw new Error(\"Você não pode fechar diretamente a conexão\")\n                        }\n                    }\n\n                    resolve(connection) //Passando para o resolve da promise, como resultado de sucesso, a connection\n                }\n\n                //Este evento é executado se houver algum erro na conexão\n                openRequest.onerror = e => {\n                    console.log(e.target.error) //Se a conexão não tiver sido bem estabelecidade, imprima no console o erro\n                    reject(e.target.error.name) //Retornando para o reject da promise, como resultado de erro, uma mensagem de erro\n                }\n\n            })\n        }\n\n        static _createStores(connection){ //Criando um método estatico para evitar repetição de código\n            stores.forEach(store => { //Percorrendo o array stores para criar ObjectStores com os nomes dentro do array\n                if(connection.objectStoreNames.contains(store)) //Conferindo se já existe algum ObjectStore já criado com o nome da posição do array, se sim, faça\n                    connection.deleteObjectStore(store) //Se já existir apague ela\n\n                //Após apagar a ObjectStore acima, crie novamente, com o mesmo nome, e tendo sua chave como auto Incremento\n                connection.createObjectStore(store, {autoIncrement: true})\n            })\n        }\n\n        static closeConnection(){ //Método estatico para fechar a conexão\n            if(connection) { //Se existir a conexão, faça\n                close() //Fechando a conexão\n                connection = null //E definir a variavel connection como null\n            }\n        }\n    }\n})()"]}